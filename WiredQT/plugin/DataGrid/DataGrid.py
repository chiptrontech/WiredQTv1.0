from PyQt5 import QtCore, QtWidgets
from PyQt5.QtGui import * 
from wired_module import * 
from copy import deepcopy

#	Generated By WiredQT for Python: by Rocky Nuarin, 2021 Phils
class Handler(QtWidgets.QWidget,usercontrol):

	#WiredEvent def clicked(model)	#add more events 

	#WiredProperty 'dbtype': 'sqllite','list':["sqllite","mysql"]

	def __init__(self, *param):    

		super(Handler, self).__init__(None)

		initUI(self,param,w=400,h=400,title="WiredQTv5.0",controlbox=True,startpos=(0,30),timeoutdestroy=-1)

		self.GTKForms()

		self.timer=QtCore.QTimer()

		self.timer.timeout.connect(self.loop)

		self.timer.start(10)       



		self.sch=Scheduler(5000)#500 ms

		self.sch.Start()

		self._dbtype="sqllite"

	@property

	def dbtype(self):

		return self._dbtype

	@dbtype.setter	

	def dbtype(self,value):

		self._dbtype=value

	def reconnectMySql(self,db):

		print ("DB has Run Away, pinging to reconnect")

		db.ping(True)

	def ExecuteNonQuerry(self,db,sql):

		curs=db.cursor()

		for a in range(2):

			try:

				curs.execute (sql)

				break

			except OperationalError as e:

				#do what you want to do on the error

				self.reconnectMySql(db)

	

		db.commit()

		return ""

	def ExecuteQuerry(self,db,sql):

		curs=db.cursor()

		for a in range(2):

			try:

				curs.execute (sql)

				break

			except OperationalError as e:

				#do what you want to do on the error

				self.reconnectMySql(db)

	

		results = curs.fetchall()

		return results

	def DataSource(self,db,sql):

		asc=self.getTable(sql,"select")

		table=self.getTable(sql)

		cols=self.getFields(db,table)        

		rec=self.ExecuteQuerry(db,sql)
		#import pdb;pdb.set_trace()
		if len(rec)==0:
			rec=deepcopy(cols)
			for i,a in enumerate(cols):
				rec[i]=""
			rec=[tuple(rec)]
			#import pdb;pdb.set_trace()
			
		self.model = TableModel(cols,rec)
		
		
		self.QTableView0.setModel(self.model)
		self.QTableView0.setStyleSheet("QHeaderView::section {background-color:#cccccc}");#header color

	def getFields(self,db,cols):

		#connectDBifRunAway()

		curs=db.cursor()

		if self._dbtype=="mysql":

			sql="SHOW COLUMNS FROM " + cols

			index=0

		if self._dbtype=="sqllite":

			sql="PRAGMA table_info("+cols+")"

			index=1

		for a in range(2):

			try:

				curs.execute (sql)

				break

			except OperationalError as e:

				#do what you want to do on the error

				self.reconnectMySql(db)

	

		results = curs.fetchall()

		ret=[]

		for a in results:

			ret.append(a[index])

		return ret

	def getTable(self,sql,after="from"):

		flag=False

		x=sql.split(" ")

		for a in x:

			if flag==True:

				if a.lower() in ["\r","\t","\n","\t"]:

					continue

				else:

					return a

			if a.lower()==after:

				flag=True

		
	def GetSingleRec(self,db,Table, Fields, Fieldsval,retvalfields):
		curs=db.cursor()
		#connectDBifRunAway()
		long=int#PYTHON3
		if type(Fieldsval)==int or type(Fieldsval)==float or type(Fieldsval)==long:
			sql="select * from " + Table + " where " + Fields + " = " + Fieldsval 
		else:#might be string or date or time    
			sql="select * from " + Table + " where " + Fields + " = '" + str(Fieldsval) + "'"
	
		#curs.execute (sql)
		for a in range(2):
			try:
				curs.execute (sql)
				break
			except OperationalError as e:
				#do what you want to do on the error
				self.reconnectMySql(db)
	
		results = curs.fetchall()
		col=self.getFields(db,Table)
		if len(results)==0:
			return ""
		for a in range(len(col)):
			if col[a]==retvalfields:
				return results[0][a]#first record only
		return ""
	def createwidget(self,prop,control,parent,event=[]):
		createWidget(self,prop,control,parent,event)         
	def GTKForms(self):
		self.createwidget("{'Enable': 'True', 'Height': '160', 'Text': '', 'Name': 'QTableView0', 'Visible': 'True', 'Left': '31', 'Var': '', 'Tag': '', 'Events': '[clicked]', 'BackColor': '(1,1,1,0.25)', 'Top': '15', 'ForeColor': '(0,0,0,1)', 'Picture': '', 'Font': '', 'ParentsType': '', 'Help': '', 'Width': '302'}",'QTableView','usercontrol',"[['clicked', 'self,arg1']]")
		self.createwidget("{'Enable': 'True', 'Height': '38', 'Text': 'Show Array Data', 'Name': 'QPushButton1', 'Visible': 'True', 'Left': '119', 'Width': '102', 'Var': '', 'Tag': '', 'Events': '[clicked]', 'BackColor': '(1,1,1,0.25)', 'Picture': '', 'Help': '', 'Font': '', 'ParentsType': '', 'Top': '184', 'ForeColor': '(0,0,0,1)'}",'QPushButton','usercontrol',"[['clicked', 'self,arg1']]")
	def Widget(self):
		return self    
	def loop(self):
		if self.form_load==False:
			self.form_load=True
		if self.sch.Event():#timer routine
			#code here
			if self.timeoutdestroy!=-1:
				self.timeoutdestroy-=1
				if self.timeoutdestroy==0:
					pass#self.unload(None)
			self.sch.Start()#restart scheduler      
		
	def connect(self,ev,evusr):
		self.wiredevents.update({ev:evusr})     
	def activeXcreated(self,*args):

		self.QTableView0.Width= self.Width-30

		self.QTableView0.Height= self.Height-30
		pass    
	def eventFilter(self, obj, event):
		return super(Handler, self).eventFilter(obj, event)
	
	def QTableView0_clicked(self,arg1):
		if self.caller!=None:

			if "clicked" in self.wiredevents:

				self.wiredevents["clicked"](arg1)
				#print(arg1.row(),arg1.column(),arg1.data())
	
	def QPushButton1_clicked(self,arg1):
		pass
if __name__ == '__main__':
	import sys
	app = QtWidgets.QApplication(sys.argv)
	w = Handler()
	w.show()
	sys.exit(app.exec_())
