from PyQt5 import QtCore, QtWidgetsfrom PyQt5.QtGui import * from wired_module import * import selectimport socketimport sysimport osfrom _thread import *#	Generated By WiredQT for Python: by Rocky Nuarin, 2021 Philsclass Handler(QtWidgets.QWidget,usercontrol):	#WiredEvent def CommEvent(conn,data)	#add more events 	#WiredEvent def ConnectionFrom(conn)	#add more events 	#WiredProperty 'Port': '5000'	#WiredProperty 'BufferSize': '1024'	#WiredProperty 'Open': 'False',"list":['True','False']	def __init__(self, *param):    		super(Handler, self).__init__(None)		initUI(self,param,w=400,h=400,title="WiredQTv5.0",controlbox=True,startpos=(0,30),timeoutdestroy=-1)		self.GTKForms()		self.timer=QtCore.QTimer()		self.timer.timeout.connect(self.loop)		self.timer.start(10)     		self.sch=Scheduler(500)#500 ms		self.sch.Start()		self._text=''		self._usercontrolproperty=''		self._BufferSize=1024		self.port=5000		HOST = ''   # Symbolic name meaning all available interfaces		self.waiting=False		self.clients=[]		self.data=None		self.conn=None		#self.activeXcreated()	def clientthread(self,conn):		self.clients.append(conn)		self.waiting=False		if self.caller!=None:			if 'ConnectionFrom' in self.wiredevents:					self.wiredevents['ConnectionFrom'](conn)		while True:			#Receiving from client			try:				ready = select.select([conn], [], [], 1)				if ready[0]:					data = conn.recv(self._BufferSize)				#reply = 'OK...' + str(num) + ' ' + data 					if not data: 						break					else:						self.conn=conn					while self.data!=None:						a=0					self.data=data			except:				break			try:				conn.sendall("".encode())  			except:				break		#came out of loop		print ("Client close")		conn.close()		self.clients.remove(conn)	def _accept(self):		conn, addr = self.s.accept()		print ('Connected with ' + addr[0] + ':' + str(addr[1]))		#start new thread takes 1st argument as a function name to be run, second is the tuple of arguments to the function.		start_new_thread(self.clientthread ,(conn,))			@property		def Port(self):		return self.port	@Port.setter		def Port(self,value):		self.port=int(value)	@property		def BufferSize(self):		return self._BufferSize	@BufferSize.setter		def BufferSize(self,value):		self._BufferSize=int(value)	def connect(self,ev,evusr):		self.wiredevents.update({ev:evusr})	def activeXcreated(self,*args):		pass	@property	def Open(self):		return ''	@Open.setter	def Open(self,value):		if value==True:			self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)			self.s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)			self.s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)				print ('Socket created')			HOST=''			#Bind socket to local host and port			try:				self.s.bind((HOST, self.port))			except (socket.error , msg):				print ('Bind failed. Error Code : ' + str(msg[0]) + ' Message ' + msg[1])				sys.exit()			print ('Socket bind complete')				#Start listening on socket			self.s.listen(10)			self.accept()			print ('Socket now listening')			if value==False:			self.s.close()		pass				def loop(self):		if self.data!=None:			if self.caller!=None:				if 'CommEvent' in self.wiredevents:						self.wiredevents['CommEvent'](self.conn,self.data)				self.data=None		if self.form_load==False:			self.form_load=True		if self.sch.Event():#timer routine			#code here			if self.timeoutdestroy!=-1:				self.timeoutdestroy-=1				if self.timeoutdestroy==0:					self.unload(None)			self.sch.Start()#restart scheduler		return True	#return true so that main_loop can call it again 		def createwidget(self,prop,control,parent,event=[]):		createWidget(self,prop,control,parent,event)	def GTKForms(self):		pass	def Widget(self):		return self	def accept(self):		if self.waiting==False:			self.waiting=True			start_new_thread(self._accept ,())		pass	def close(self):		for a in self.clients:			a.close()		self.s.closeif __name__ == '__main__':	import sys	app = QtWidgets.QApplication(sys.argv)	w = Handler()	w.show()	sys.exit(app.exec_())