from PyQt5 import QtCore, QtWidgets
from PyQt5.QtGui import * 
from wired_module import *
import select
import socket
import sys
import os
from _thread import *
#	Generated By WiredQT for Python: by Rocky Nuarin, 2021 Phils

class Handler(QtWidgets.QWidget,usercontrol):
	#WiredEvent def CommEvent(conn,data)	#add more events 
	#WiredEvent def ConnectionFrom(conn)	#add more events 
	#WiredProperty 'Port': '5000'
	#WiredProperty 'Address': 'localhost'
	#WiredProperty 'BufferSize': '1024'
	#WiredProperty 'Open': 'False',"list":['True','False']
	def __init__(self, *param):    
		super(Handler, self).__init__(None)
		initUI(self,param,w=400,h=400,title="WiredQTv5.0",controlbox=True,startpos=(0,30),timeoutdestroy=-1)
		self.GTKForms()
		self.timer=QtCore.QTimer()
		self.timer.timeout.connect(self.loop)
		self.timer.start(10)
		self.sch=Scheduler(500)#500 ms
		self.sch.Start()
		self._text=''
		self._usercontrolproperty=''
		self._BufferSize=1024
		self.address='localhost'
		self.port=5000
		HOST = ''   # Symbolic name meaning all available interfaces
		self.conn=None
		self.data=None
		self.fin=True
		#self.activeXcreated()

	def clientthread(self,conn):

		if self.caller!=None:
			if 'ConnectionFrom' in self.wiredevents:	
				self.wiredevents['ConnectionFrom'](conn)
		while True:
			#Receiving from client
			try:
				ready = select.select([conn], [], [], 1)
				if ready[0]:
					data = conn.recv(self._BufferSize)
				#reply = 'OK...' + str(num) + ' ' + data 
					if not data: 
						break
					else:
						self.conn=conn
					while self.data!=None:
						a=0
					self.data=data
			except:
				break
			try:
				conn.sendall("".encode())  
			except:
				break
		#came out of loop
		print ("Server close")
		conn.close()
	def _accept(self):
		start_new_thread(self.clientthread ,(self.s,))
	@property	
	def Port(self):
		return self.port
	@Port.setter	
	def Port(self,value):
		self.port=int(value)
	@property	
	def Address(self):
		return self.address
	@Address.setter	
	def Address(self,value):
		self.address=value	
	@property	
	def BufferSize(self):
		return self._BufferSize
	@BufferSize.setter	
	def BufferSize(self,value):
		self._BufferSize=int(value)
	def connect(self,ev,evusr):
		self.wiredevents.update({ev:evusr})
	def reconnect(self):
		start_new_thread(self.reconnectt_thread ,())
	def reconnectt_thread(self):
		if self.fin:
			self.fin=False
			self.s.close()
			delay(1)
			self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			try:
				self.s.connect((self.address, self.port))
				start_new_thread(self._accept ,())
			except:
				print("cannot connect to ",self.address)		
			self.fin=True
	def activeXcreated(self,*args):
		pass
	@property
	def Open(self):
		return ''
	@Open.setter
	def Open(self,value):
		if value==True:	
			self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			try:
				self.s.connect((self.address, self.port))
				start_new_thread(self._accept ,())
			except:
				print("cannot connect to ",self.address)
		if value==False:
			self.s.close()
		pass				
		
	def loop(self):
		if self.data!=None:
			if self.caller!=None:
				if 'CommEvent' in self.wiredevents:	
					self.wiredevents['CommEvent'](self.conn,self.data)	
			self.data=None
		if self.form_load==False:
			self.form_load=True
		if self.sch.Event():#timer routine
			#code here
			if self.timeoutdestroy!=-1:
				self.timeoutdestroy-=1
				if self.timeoutdestroy==0:
					self.unload(None)
			self.sch.Start()#restart scheduler
		return True	#return true so that main_loop can call it again 	
	def createwidget(self,prop,control,parent,event=[]):
		createWidget(self,prop,control,parent,event)
	def GTKForms(self):		pass	def Widget(self):
		return self
	def sendall(self,data):
		self.s.sendall(data)
		
	def close(self):
		for a in self.clients:
			a.close()
		self.s.close
if __name__ == '__main__':
	import sys
	app = QtWidgets.QApplication(sys.argv)
	w = Handler()
	w.show()
	sys.exit(app.exec_())